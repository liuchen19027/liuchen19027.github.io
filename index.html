<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <!-- 确保页面在移动设备上正确缩放，并使用设备宽度作为视口宽度 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>温馨提示 - 心形排列</title>
    <style>
        /* 根字体大小，用于rem单位的基准，可以根据视口宽度动态调整 */
        html {
            font-size: 16px; /* 默认基准 */
        }
        @media (max-width: 768px) { /* 针对小屏幕/手机 */
            html {
                font-size: 13px; /* 手机上进一步缩小基准字体 */
            }
        }
        @media (max-width: 480px) { /* 针对更小的手机屏幕 */
            html {
                font-size: 11px; /* 进一步缩小 */
            }
        }

        body {
            font-family: '微软雅黑', sans-serif;
            margin: 0;
            background-color: #f0f2f5; /* 页面背景色 */
            overflow: hidden; /* 防止窗口溢出时出现滚动条 */
            min-height: 100vh; /* 确保占满整个视口高度 */
            display: flex;
            justify-content: center; /* 水平居中 */
            align-items: center; /* 垂直居中 */
            position: relative; /* 用于子元素的绝对定位 */
            touch-action: manipulation; /* 阻止双击缩放，提升移动端体验 */
        }

        /* 提示框的样式 */
        .tip-container {
            position: absolute; /* 绝对定位，用于心形排列 */
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 0.4rem; /* 圆角，略微缩小 */
            box-shadow: 0 0.1rem 0.25rem rgba(0, 0, 0, 0.15); /* 阴影效果，略微缩小 */
            font-size: 0.7rem; /* 字体大小，进一步缩小 */
            color: #333; /* 字体颜色 */
            padding: 0.25rem 0.4rem; /* 内边距，进一步缩小 */
            box-sizing: border-box; /* 包含padding在宽度内 */
            text-align: center;
            opacity: 0; /* 初始隐藏 */
            /* 使用transform进行居中和位移，性能更好 */
            transform: translate(-50%, -50%) scale(0.8); /* 初始缩小 */
            transition: opacity 0.5s ease-out, transform 0.5s ease-out; /* 动画过渡 */
            white-space: normal; /* 允许文本换行 */
            word-break: break-all; /* 单词内换行，防止超长英文单词撑开 */
            max-width: 6rem; /* 最大宽度设置为rem单位，进一步缩小 */
            min-height: 1.5rem; /* 设置最小高度，防止内容过少时太扁 */
            line-height: 1.2; /* 行高，让文本更紧凑 */
            /* z-index 将由JS动态设置 */
        }

        /* 提示框显示时的样式 */
        .tip-container.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            transition: opacity 0.8s ease-in, transform 0.8s ease-in; /* 显示时的动画慢一些 */
        }
    </style>
</head>
<body>
    <script>
        const tips = [
            '多喝水哦~', '保持微笑呀', '每天都要元气满满',
            '记得吃水果', '保持好心情', '好好爱自己', '我想你了',
            '梦想成真', '期待下一次见面', '金榜题名',
            '顺顺利利', '早点休息', '愿所有烦恼都消失',
            '别熬夜', '今天过得开心嘛', '天冷了，多穿衣服',
            '注意休息哦', '按时吃饭呀', '工作再忙也要照顾好自己',
            '一切都会好起来的', '加油，你是最棒的！', '未来可期',
            '祝你前程似锦', '祝你心想事成', '想念你的每一天',
            '有你真好', '你是我的小太阳', '别忘了吃早餐',
            '路上注意安全', '保持阳光心态', '凡事看开一点',
            '你一定可以的！', '好好享受生活', '愿你每天都充满力量',
            '记得补充维生素', '睡前泡个脚会更舒服哦', '想和你分享今天的一切',
            '有我在呢', '祝你万事如意', '笑一笑，没什么大不了',
            '给自己一点掌声', '雨天记得带伞', '天气炎热，注意防晒',
            '保持愉悦的心情', '做你想做的事吧', '你的努力终会有回报',
            '别给自己太大压力', '偶尔偷个懒也无妨', '期待与你再相见',
            '我一直都在'
        ]; // 完整提示列表

        const bgColors = [
            '#ffb6c1', '#87ceeb', '#90ee90', '#e6e6fa',
            '#ffffe0', '#dda0dd', '#ff7f50', '#ffe4c4',
            '#7fffd4', '#ffe4e1', '#f0fff0', '#fff0f5', '#faebd7'
        ];

        // --- 核心修改：减少生成总数和调整生成速度 ---
        const totalTipsToGenerate = 45; // 保持45个，如果觉得不够可以适当增加
        const delayBetweenTips = 250; // 毫秒

        function getRandomElement(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        // 生成心形坐标点的函数
        function getHeartCoordinates(count) {
            const points = [];
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            // --- 修复点：调整心形最大尺寸比例，并修正原始方程范围的理解 ---
            // 确保心形占据屏幕的合理比例，为提示框留出更多空间
            const targetHeartWidthRatio = 0.6; // 心形宽度占视口宽度的比例
            const targetHeartHeightRatio = 0.65; // 心形高度占视口高度的比例

            const maxHeartWidth = viewportWidth * targetHeartWidthRatio;
            const maxHeartHeight = viewportHeight * targetHeartHeightRatio;

            // 原始心形方程的 X 和 Y 范围 (通过对公式求值分析得到)
            // 16 * sin^3(t) 的理论范围是 [-16, 16]
            const originalMaxXRange = 16 * 2; // 32

            // (13*cos(t) - 5*cos(2t) - 2*cos(3t) - cos(4t)) 的最大值约 11.6，最小值约 -16.89
            // 乘以负号后，Y 值的范围大约是 [-11.6, 16.89]
            const originalMinYValue = -11.6; // 实际方程Y轴的最小值
            const originalMaxYValue = 16.89; // 实际方程Y轴的最大值
            const originalMaxYRange = originalMaxYValue - originalMinYValue; // 实际Y轴的跨度

            // 计算 X 和 Y 的缩放因子
            const scaleFactorX = maxHeartWidth / originalMaxXRange;
            const scaleFactorY = maxHeartHeight / originalMaxYRange;

            // 取两者较小值，以确保心形完全适应屏幕，并保持其纵横比
            const effectiveScale = Math.min(scaleFactorX, scaleFactorY);

            // 最终的 scaleX 和 scaleY，这两个值直接乘以参数方程的系数
            // 原始方程：x = A * (16 * sin^3(t)), y = -B * (13*cos(t) - ...)
            // 这里的 scaleX 和 scaleY 就对应着 A 和 B
            // 错误修复：这里的 scaleX 和 scaleY 应该是直接应用于心形方程的整体缩放，
            // 而不是再乘以原始方程内部的系数。
            // 它们代表着 1单位的图形在屏幕上对应多少像素。
            const finalScale = effectiveScale; // 直接使用 effectiveScale 作为最终缩放

            // 垂直偏移量，确保心形在垂直方向上居中或稍微偏上
            // originalMinYValue 和 originalMaxYValue 是基于未缩放前的Y轴理论值
            // 我们需要将整个心形垂直平移，使其在视口中居中
            // 缩放后的心形实际高度 = originalMaxYRange * finalScale
            // 缩放后的心形顶部到中心线的距离 = (originalMaxYValue - originalMaxYRange / 2) * finalScale
            // 缩放后的心形底部到中心线的距离 = (originalMinYValue + originalMaxYRange / 2) * finalScale
            // 为了让心形垂直居中，我们需要将心形的中心点 (originalMinYValue + originalMaxYRange / 2) * finalScale 移到视口中心。
            // 目标中心Y = viewportHeight / 2
            // 原始心形中心Y（未经缩放）= (originalMaxYValue + originalMinYValue) / 2
            // 缩放后的心形中心Y = originalHeartCenterY * finalScale
            // 我们希望心形中心在 Y 轴上的偏移量，可以使得心形整体略微偏上。
            const initialYOffset = -((originalMaxYValue + originalMinYValue) / 2) * finalScale; // 使心形中心对齐Y=0
            const additionalOffsetY = -0.05 * viewportHeight; // 额外向上偏移视口高度的5%

            const offsetY = initialYOffset + additionalOffsetY; // 最终的Y轴偏移量

            for (let i = 0; i < count; i++) {
                const t = (i / count) * Math.PI * 2; // t从0到2π

                // 心形参数方程
                const x = finalScale * (16 * Math.pow(Math.sin(t), 3));
                const y = -finalScale * (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t)); // 负号使心形朝上

                points.push({ x: x, y: y + offsetY }); // 加上偏移量
            }
            return points;
        }

        let heartPoints = [];
        let generatedCount = 0;
        const tipElements = []; // 用于存储生成的提示框元素

        function createAndDisplayTipInHeartShape() {
            if (generatedCount >= totalTipsToGenerate) {
                return; // 如果已生成所有提示，则停止
            }

            // 获取当前提示框应该放置的心形坐标
            const point = heartPoints[generatedCount];

            const tipText = getRandomElement(tips);
            const bgColor = getRandomElement(bgColors);

            const newTipElement = document.createElement('div');
            newTipElement.classList.add('tip-container');
            newTipElement.textContent = tipText;
            newTipElement.style.backgroundColor = bgColor;

            newTipElement.style.left = `50%`;
            newTipElement.style.top = `50%`;
            // 修正：确保初始的transform也带有心形坐标，这样transition才能正确从初始位置开始
            newTipElement.style.transform = `translate(calc(-50% + ${point.x}px), calc(-50% + ${point.y}px)) scale(0.8)`;


            // 设置 z-index 以实现堆叠效果，后生成的在前面
            newTipElement.style.zIndex = generatedCount + 1;

            document.body.appendChild(newTipElement);
            tipElements.push(newTipElement); // 存储元素以便后续更新

            // 延迟一点点时间（让浏览器渲染元素后再添加'show'类）
            setTimeout(() => {
                newTipElement.classList.add('show');
                // 修正：当'show'类被添加时，才将transform的scale设置为1，使其动画生效
                newTipElement.style.transform = `translate(calc(-50% + ${point.x}px), calc(-50% + ${point.y}px)) scale(1)`;
            }, 10);

            generatedCount++;
            if (generatedCount < totalTipsToGenerate) {
                setTimeout(createAndDisplayTipInHeartShape, delayBetweenTips);
            }
        }

        // 重新定位所有已生成的提示框
        function repositionTips() {
            heartPoints = getHeartCoordinates(totalTipsToGenerate); // 重新计算心形点

            tipElements.forEach((tipElement, index) => {
                if (tipElement.classList.contains('show') && index < heartPoints.length) {
                    const point = heartPoints[index];
                    // 重新应用transform，使其在新的心形坐标上居中
                    // 保持当前的scale状态 (scale(1) 如果已显示，scale(0.8) 如果是初始状态)
                    const currentScale = tipElement.classList.contains('show') ? 'scale(1)' : 'scale(0.8)';
                    tipElement.style.transform = `translate(calc(-50% + ${point.x}px), calc(-50% + ${point.y}px)) ${currentScale}`;
                }
            });
        }

        // 页面加载完成后开始生成提示
        window.addEventListener('load', () => {
            // 确保 tips 数组有足够的内容，防止因为内容过少而循环取不到值
            if (tips.length === 0) {
                console.warn("Tips array is empty!");
                return;
            }
            repositionTips(); // 初始计算并定位
            createAndDisplayTipInHeartShape();
        });

        // 窗口大小改变时，重新计算并重新定位所有提示框
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                repositionTips();
            }, 200); // 200ms 后执行，避免在窗口大小调整过程中频繁计算
        });
    </script>
</body>
</html>
