<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <!-- 关键优化：确保页面在移动设备上正确缩放，并使用设备宽度作为视口宽度 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>温馨提示 - 心形排列</title>
    <style>
        /* 根字体大小，用于rem单位的基准，可以根据视口宽度动态调整 */
        html {
            font-size: 16px; /* 默认基准 */
        }
        @media (max-width: 768px) { /* 针对小屏幕/手机 */
            html {
                font-size: 13px; /* 手机上进一步缩小基准字体 */
            }
        }
        @media (max-width: 480px) { /* 针对更小的手机屏幕 */
            html {
                font-size: 11px; /* 进一步缩小 */
            }
        }

        body {
            font-family: '微软雅黑', sans-serif;
            margin: 0;
            background-color: #f0f2f5; /* 页面背景色 */
            overflow: hidden; /* 防止窗口溢出时出现滚动条 */
            min-height: 100vh; /* 确保占满整个视口高度 */
            display: flex;
            justify-content: center; /* 水平居中 */
            align-items: center; /* 垂直居中 */
            position: relative; /* 用于子元素的绝对定位 */
            touch-action: manipulation; /* 阻止双击缩放，提升移动端体验 */
        }

        /* 提示框的样式 */
        .tip-container {
            position: absolute; /* 绝对定位，用于心形排列 */
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 0.4rem; /* 圆角，略微缩小 */
            box-shadow: 0 0.1rem 0.25rem rgba(0, 0, 0, 0.15); /* 阴影效果，略微缩小 */
            font-size: 0.7rem; /* 字体大小，进一步缩小 */
            color: #333; /* 字体颜色 */
            padding: 0.25rem 0.4rem; /* 内边距，进一步缩小 */
            box-sizing: border-box; /* 包含padding在宽度内 */
            text-align: center;
            opacity: 0; /* 初始隐藏 */
            /* 使用transform进行居中和位移，性能更好 */
            transform: translate(-50%, -50%) scale(0.8); /* 初始缩小 */
            transition: opacity 0.5s ease-out, transform 0.5s ease-out; /* 动画过渡 */
            white-space: normal; /* 允许文本换行 */
            word-break: break-all; /* 单词内换行，防止超长英文单词撑开 */
            max-width: 6rem; /* 最大宽度设置为rem单位，进一步缩小 */
            min-height: 1.5rem; /* 设置最小高度，防止内容过少时太扁 */
            line-height: 1.2; /* 行高，让文本更紧凑 */
            /* z-index 将由JS动态设置 */
        }

        /* 提示框显示时的样式 */
        .tip-container.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            transition: opacity 0.8s ease-in, transform 0.8s ease-in; /* 显示时的动画慢一些 */
        }
    </style>
</head>
<body>
    <script>
        const tips = [
            '多喝水哦~', '保持微笑呀', '每天都要元气满满',
            '记得吃水果', '保持好心情', '好好爱自己', '我想你了',
            '梦想成真', '期待下一次见面', '金榜题名',
            '顺顺利利', '早点休息', '愿所有烦恼都消失',
            '别熬夜', '今天过得开心嘛', '天冷了，多穿衣服'
        ];

        const bgColors = [
            '#ffb6c1', '#87ceeb', '#90ee90', '#e6e6fa',
            '#ffffe0', '#dda0dd', '#ff7f50', '#ffe4c4',
            '#7fffd4', '#ffe4e1', '#f0fff0', '#fff0f5', '#faebd7'
        ];

        // --- 核心修改：减少生成总数和调整生成速度 ---
        const totalTipsToGenerate = 45; // 从80减少到45，大大减少元素数量
        const delayBetweenTips = 250; // 从400减少到250毫秒，加快生成速度

        function getRandomElement(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        // 生成心形坐标点的函数
        function getHeartCoordinates(count) {
            const points = [];
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            // --- 核心修改：更保守地计算心形的最大尺寸 ---
            // 心形最大宽度和高度占据视口更小的比例
            const maxHeartWidth = viewportWidth * 0.55; // 心形最大宽度占视口宽度的55%
            const maxHeartHeight = viewportHeight * 0.6; // 心形最大高度占视口高度的60%

            // 原始心形方程的X范围大约是[-16, 16]，Y范围大约是[-20, 12] （经过公式简化后的相对值）
            // 考虑公式：x = scaleX * (16 * sin^3(t))
            //         y = -scaleY * (13*cos(t) - 5*cos(2t) - 2*cos(3t) - cos(4t))
            // 16 * sin^3(t) 范围是 [-16, 16]
            // (13*cos(t) - 5*cos(2t) - 2*cos(3t) - cos(4t)) 范围大约是 [-17, 12]
            const originalEquationRangeX = 16 * 2; // 32
            const originalEquationRangeY = 17 + 12; // 29

            // 计算缩放因子
            // 这里的 16 和 18 是原始公式的系数，我们希望新的心形尺寸由 maxHeartWidth/Height 决定
            // 所以 (maxHeartWidth / originalEquationRangeX) * (原始X系数16)
            // (maxHeartHeight / originalEquationRangeY) * (原始Y系数18)
            const scaleFactorX = maxHeartWidth / originalEquationRangeX;
            const scaleFactorY = maxHeartHeight / originalEquationRangeY;

            // 取两者较小的，确保心形能完整显示在屏幕内，且形状不变形
            const effectiveScale = Math.min(scaleFactorX, scaleFactorY);

            // 最终的缩放参数，这两个值直接决定了心形的物理尺寸
            const scaleX = effectiveScale * 16; // 对应公式中的16
            const scaleY = effectiveScale * 18; // 对应公式中的18，调整以匹配纵横比

            // 垂直偏移量，使用vh确保相对性
            // 调整心形垂直位置，使中心更靠上或居中，根据实际效果调整
            const offsetY = -0.05 * viewportHeight; // 例如，向上偏移视口高度的5%

            for (let i = 0; i < count; i++) {
                const t = (i / count) * Math.PI * 2; // t从0到2π

                // 心形参数方程
                const x = scaleX * (16 * Math.pow(Math.sin(t), 3));
                const y = -scaleY * (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t)); // 负号使心形朝上

                points.push({ x: x, y: y + offsetY }); // 加上偏移量
            }
            return points;
        }

        let heartPoints = [];
        let generatedCount = 0;
        const tipElements = []; // 用于存储生成的提示框元素

        function createAndDisplayTipInHeartShape() {
            if (generatedCount >= totalTipsToGenerate) {
                return; // 如果已生成所有提示，则停止
            }

            // 获取当前提示框应该放置的心形坐标
            const point = heartPoints[generatedCount];

            const tipText = getRandomElement(tips);
            const bgColor = getRandomElement(bgColors);

            const newTipElement = document.createElement('div');
            newTipElement.classList.add('tip-container');
            newTipElement.textContent = tipText;
            newTipElement.style.backgroundColor = bgColor;

            // 定位：使用left/top 50% 配合 transform translate(-50%, -50%) 居中
            // 然后再叠加心形坐标的偏移
            newTipElement.style.left = `50%`;
            newTipElement.style.top = `50%`;
            // 使用 transform 叠加偏移，可以保证元素中心对齐坐标点，且性能更优
            newTipElement.style.transform = `translate(calc(-50% + ${point.x}px), calc(-50% + ${point.y}px)) scale(0.8)`;


            // 设置 z-index 以实现堆叠效果，后生成的在前面
            newTipElement.style.zIndex = generatedCount + 1;

            document.body.appendChild(newTipElement);
            tipElements.push(newTipElement); // 存储元素以便后续更新

            // 延迟一点点时间（让浏览器渲染元素后再添加'show'类）
            setTimeout(() => {
                newTipElement.classList.add('show');
                // 确保transform属性在show类添加后能正确过渡
                newTipElement.style.transform = `translate(calc(-50% + ${point.x}px), calc(-50% + ${point.y}px)) scale(1)`;
            }, 10);

            generatedCount++;
            if (generatedCount < totalTipsToGenerate) {
                setTimeout(createAndDisplayTipInHeartShape, delayBetweenTips);
            }
        }

        // 重新定位所有已生成的提示框
        function repositionTips() {
            heartPoints = getHeartCoordinates(totalTipsToGenerate); // 重新计算心形点

            tipElements.forEach((tipElement, index) => {
                if (tipElement.classList.contains('show') && index < heartPoints.length) {
                    const point = heartPoints[index];
                    // 重新应用transform，使其在新的心形坐标上居中
                    tipElement.style.transform = `translate(calc(-50% + ${point.x}px), calc(-50% + ${point.y}px)) ${tipElement.classList.contains('show') ? 'scale(1)' : 'scale(0.8)'}`;
                }
            });
        }

        // 页面加载完成后开始生成提示
        window.addEventListener('load', () => {
            repositionTips(); // 初始计算并定位
            createAndDisplayTipInHeartShape();
        });

        // 窗口大小改变时，重新计算并重新定位所有提示框
        // 这对于手机横竖屏切换时尤其重要
        // 使用防抖动 (debounce) 优化 resize 事件，避免频繁触发
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                repositionTips();
            }, 200); // 200ms 后执行，避免在窗口大小调整过程中频繁计算
        });
    </script>
</body>
</html>
